import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a as assign, v as validate_slots, e as exclude_internal_props, b as svg_element, c as claim_element, f as children, g as detach_dev, h as attr_dev, j as add_location, k as set_svg_attributes, l as insert_dev, m as append_dev, n as get_spread_update, o as noop, p as space, q as element, t as text, r as create_component, u as query_selector_all, w as claim_space, x as claim_text, y as claim_component, z as mount_component, A as get_spread_object, B as transition_in, C as transition_out, D as destroy_component } from './client.d845b9be.js';

/* static/score.svg generated by Svelte v3.23.0 */

const file = "static/score.svg";

function create_fragment(ctx) {
	let svg;
	let path0;
	let path1;

	let svg_levels = [
		{ xmlns: "http://www.w3.org/2000/svg" },
		{ height: "24" },
		{ viewBox: "0 0 24 24" },
		{ width: "24" },
		/*$$props*/ ctx[0]
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					height: true,
					viewBox: true,
					width: true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
			children(path0).forEach(detach_dev);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M0 0h24v24H0z");
			attr_dev(path0, "fill", "none");
			add_location(path0, file, 0, 96, 96);
			attr_dev(path1, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 2h1.5v3l2-3h1.7l-2 3 2 3h-1.7l-2-3v3H12V5zM7 7.25h2.5V6.5H7V5h4v3.75H8.5v.75H11V11H7V7.25zM19 13l-6 6-4-4-4 4v-2.5l4-4 4 4 6-6V13z");
			add_location(path1, file, 0, 133, 133);
			set_svg_attributes(svg, svg_data);
			add_location(svg, file, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ xmlns: "http://www.w3.org/2000/svg" },
				{ height: "24" },
				{ viewBox: "0 0 24 24" },
				{ width: "24" },
				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Score", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class Score extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Score",
			options,
			id: create_fragment.name
		});
	}
}

/* static/weight.svg generated by Svelte v3.23.0 */

const file$1 = "static/weight.svg";

function create_fragment$1(ctx) {
	let svg;
	let path0;
	let path1;

	let svg_levels = [
		{ xmlns: "http://www.w3.org/2000/svg" },
		{ height: "24" },
		{ viewBox: "0 0 24 24" },
		{ width: "24" },
		/*$$props*/ ctx[0]
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					xmlns: true,
					height: true,
					viewBox: true,
					width: true
				},
				1
			);

			var svg_nodes = children(svg);
			path0 = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
			children(path0).forEach(detach_dev);
			path1 = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M0 0h24v24H0z");
			attr_dev(path0, "fill", "none");
			add_location(path0, file$1, 0, 96, 96);
			attr_dev(path1, "d", "M20.57 14.86L22 13.43 20.57 12 17 15.57 8.43 7 12 3.43 10.57 2 9.14 3.43 7.71 2 5.57 4.14 4.14 2.71 2.71 4.14l1.43 1.43L2 7.71l1.43 1.43L2 10.57 3.43 12 7 8.43 15.57 17 12 20.57 13.43 22l1.43-1.43L16.29 22l2.14-2.14 1.43 1.43 1.43-1.43-1.43-1.43L22 16.29z");
			add_location(path1, file$1, 0, 133, 133);
			set_svg_attributes(svg, svg_data);
			add_location(svg, file$1, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				{ xmlns: "http://www.w3.org/2000/svg" },
				{ height: "24" },
				{ viewBox: "0 0 24 24" },
				{ width: "24" },
				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Weight", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class Weight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Weight",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/how-it-works.svelte generated by Svelte v3.23.0 */
const file$2 = "src/routes/how-it-works.svelte";

function create_fragment$2(ctx) {
	let t0;
	let h1;
	let t1;
	let t2;
	let p0;
	let t3;
	let t4;
	let ul;
	let li0;
	let div2;
	let div0;
	let t5;
	let div1;
	let t6;
	let div2_class_value;
	let t7;
	let li1;
	let div5;
	let div3;
	let t8;
	let div4;
	let t9;
	let div5_class_value;
	let t10;
	let li2;
	let div8;
	let div6;
	let t11;
	let div7;
	let t12;
	let div8_class_value;
	let t13;
	let div9;
	let t14;
	let t15;
	let div14;
	let div11;
	let div10;
	let h20;
	let t16;
	let t17;
	let img0;
	let img0_src_value;
	let t18;
	let p1;
	let t19;
	let t20;
	let div13;
	let div12;
	let h21;
	let t21;
	let t22;
	let img1;
	let img1_src_value;
	let t23;
	let p2;
	let t24;
	let current;
	const splitsvg_spread_levels = [/*svgProps*/ ctx[1]];
	let splitsvg_props = {};

	for (let i = 0; i < splitsvg_spread_levels.length; i += 1) {
		splitsvg_props = assign(splitsvg_props, splitsvg_spread_levels[i]);
	}

	const splitsvg = new Score({ props: splitsvg_props, $$inline: true });
	const weightsvg_spread_levels = [/*svgProps*/ ctx[1]];
	let weightsvg_props = {};

	for (let i = 0; i < weightsvg_spread_levels.length; i += 1) {
		weightsvg_props = assign(weightsvg_props, weightsvg_spread_levels[i]);
	}

	const weightsvg = new Weight({ props: weightsvg_props, $$inline: true });
	const scoresvg_spread_levels = [/*svgProps*/ ctx[1]];
	let scoresvg_props = {};

	for (let i = 0; i < scoresvg_spread_levels.length; i += 1) {
		scoresvg_props = assign(scoresvg_props, scoresvg_spread_levels[i]);
	}

	const scoresvg = new Score({ props: scoresvg_props, $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			h1 = element("h1");
			t1 = text("Getting Started");
			t2 = space();
			p0 = element("p");
			t3 = text("At its heart, this is just a Game of Life sandbox. Relax and just watch it unfold. If you want to try and make it into the High scores, read on.");
			t4 = space();
			ul = element("ul");
			li0 = element("li");
			div2 = element("div");
			div0 = element("div");
			create_component(splitsvg.$$.fragment);
			t5 = space();
			div1 = element("div");
			t6 = text("The game consists of 2 main \"games\", a game of Life and a game of Death");
			t7 = space();
			li1 = element("li");
			div5 = element("div");
			div3 = element("div");
			create_component(weightsvg.$$.fragment);
			t8 = space();
			div4 = element("div");
			t9 = text("They are both played in the same game mode, we just weight various metrics differently.");
			t10 = space();
			li2 = element("li");
			div8 = element("div");
			div6 = element("div");
			create_component(scoresvg.$$.fragment);
			t11 = space();
			div7 = element("div");
			t12 = text("At the end, we check to see if you might have made it ontoto the high score list for your seed and edit count.");
			t13 = space();
			div9 = element("div");
			t14 = text("There will eventually be more game modes with more levels of interaction. Stay Tuned!!!");
			t15 = space();
			div14 = element("div");
			div11 = element("div");
			div10 = element("div");
			h20 = element("h2");
			t16 = text("Life Score");
			t17 = space();
			img0 = element("img");
			t18 = space();
			p1 = element("p");
			t19 = text("The main goal is to achieve a high Life Score by making the game live as long as possible. We then compare your results with other results that were created using the same edit counts. An edit is toggling a cell on or off. There is no penalty to a toggle, its just a different high score list.");
			t20 = space();
			div13 = element("div");
			div12 = element("div");
			h21 = element("h2");
			t21 = text("Death Score");
			t22 = space();
			img1 = element("img");
			t23 = space();
			p2 = element("p");
			t24 = text("There is also the concept of a Death Score. How empty can you leave the board? The amount of living cells at the end is the primary metric here. In the event of a tie, a shorter lifespan is better.");
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-13pz53p\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, "Getting Started");
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			p0 = claim_element(nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t3 = claim_text(p0_nodes, "At its heart, this is just a Game of Life sandbox. Relax and just watch it unfold. If you want to try and make it into the High scores, read on.");
			p0_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			div2 = claim_element(li0_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", {});
			var div0_nodes = children(div0);
			claim_component(splitsvg.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", {});
			var div1_nodes = children(div1);
			t6 = claim_text(div1_nodes, "The game consists of 2 main \"games\", a game of Life and a game of Death");
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			li0_nodes.forEach(detach_dev);
			t7 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			div5 = claim_element(li1_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div3 = claim_element(div5_nodes, "DIV", {});
			var div3_nodes = children(div3);
			claim_component(weightsvg.$$.fragment, div3_nodes);
			div3_nodes.forEach(detach_dev);
			t8 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", {});
			var div4_nodes = children(div4);
			t9 = claim_text(div4_nodes, "They are both played in the same game mode, we just weight various metrics differently.");
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			li1_nodes.forEach(detach_dev);
			t10 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			div8 = claim_element(li2_nodes, "DIV", { class: true });
			var div8_nodes = children(div8);
			div6 = claim_element(div8_nodes, "DIV", {});
			var div6_nodes = children(div6);
			claim_component(scoresvg.$$.fragment, div6_nodes);
			div6_nodes.forEach(detach_dev);
			t11 = claim_space(div8_nodes);
			div7 = claim_element(div8_nodes, "DIV", {});
			var div7_nodes = children(div7);
			t12 = claim_text(div7_nodes, "At the end, we check to see if you might have made it ontoto the high score list for your seed and edit count.");
			div7_nodes.forEach(detach_dev);
			div8_nodes.forEach(detach_dev);
			li2_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			div9 = claim_element(nodes, "DIV", { class: true });
			var div9_nodes = children(div9);
			t14 = claim_text(div9_nodes, "There will eventually be more game modes with more levels of interaction. Stay Tuned!!!");
			div9_nodes.forEach(detach_dev);
			t15 = claim_space(nodes);
			div14 = claim_element(nodes, "DIV", { class: true });
			var div14_nodes = children(div14);
			div11 = claim_element(div14_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			div10 = claim_element(div11_nodes, "DIV", { class: true });
			var div10_nodes = children(div10);
			h20 = claim_element(div10_nodes, "H2", { class: true });
			var h20_nodes = children(h20);
			t16 = claim_text(h20_nodes, "Life Score");
			h20_nodes.forEach(detach_dev);
			t17 = claim_space(div10_nodes);
			img0 = claim_element(div10_nodes, "IMG", { class: true, src: true, alt: true });
			div10_nodes.forEach(detach_dev);
			t18 = claim_space(div11_nodes);
			p1 = claim_element(div11_nodes, "P", {});
			var p1_nodes = children(p1);
			t19 = claim_text(p1_nodes, "The main goal is to achieve a high Life Score by making the game live as long as possible. We then compare your results with other results that were created using the same edit counts. An edit is toggling a cell on or off. There is no penalty to a toggle, its just a different high score list.");
			p1_nodes.forEach(detach_dev);
			div11_nodes.forEach(detach_dev);
			t20 = claim_space(div14_nodes);
			div13 = claim_element(div14_nodes, "DIV", { class: true });
			var div13_nodes = children(div13);
			div12 = claim_element(div13_nodes, "DIV", { class: true });
			var div12_nodes = children(div12);
			h21 = claim_element(div12_nodes, "H2", { class: true });
			var h21_nodes = children(h21);
			t21 = claim_text(h21_nodes, "Death Score");
			h21_nodes.forEach(detach_dev);
			t22 = claim_space(div12_nodes);
			img1 = claim_element(div12_nodes, "IMG", { class: true, src: true, alt: true });
			div12_nodes.forEach(detach_dev);
			t23 = claim_space(div13_nodes);
			p2 = claim_element(div13_nodes, "P", {});
			var p2_nodes = children(p2);
			t24 = claim_text(p2_nodes, "There is also the concept of a Death Score. How empty can you leave the board? The amount of living cells at the end is the primary metric here. In the event of a tie, a shorter lifespan is better.");
			p2_nodes.forEach(detach_dev);
			div13_nodes.forEach(detach_dev);
			div14_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "How it Works";
			add_location(h1, file$2, 78, 0, 1656);
			attr_dev(p0, "class", "how-it-works-description svelte-oe7jt1");
			add_location(p0, file$2, 79, 0, 1681);
			add_location(div0, file$2, 83, 6, 1984);
			add_location(div1, file$2, 84, 6, 2028);
			attr_dev(div2, "class", div2_class_value = "slide-animation-wrapper first " + (/*shouldAnimate*/ ctx[0] && "done") + " svelte-oe7jt1");
			add_location(div2, file$2, 82, 4, 1908);
			attr_dev(li0, "class", "svelte-oe7jt1");
			add_location(li0, file$2, 81, 2, 1899);
			add_location(div3, file$2, 89, 6, 2218);
			add_location(div4, file$2, 90, 6, 2263);
			attr_dev(div5, "class", div5_class_value = "slide-animation-wrapper second " + (/*shouldAnimate*/ ctx[0] && "done") + " svelte-oe7jt1");
			add_location(div5, file$2, 88, 4, 2141);
			attr_dev(li1, "class", "svelte-oe7jt1");
			add_location(li1, file$2, 87, 2, 2132);
			add_location(div6, file$2, 95, 6, 2468);
			add_location(div7, file$2, 96, 6, 2512);
			attr_dev(div8, "class", div8_class_value = "slide-animation-wrapper third " + (/*shouldAnimate*/ ctx[0] && "done") + " svelte-oe7jt1");
			add_location(div8, file$2, 94, 4, 2392);
			attr_dev(li2, "class", "svelte-oe7jt1");
			add_location(li2, file$2, 93, 2, 2383);
			attr_dev(ul, "class", "how-it-works-list svelte-oe7jt1");
			add_location(ul, file$2, 80, 0, 1866);
			attr_dev(div9, "class", "warning");
			add_location(div9, file$2, 102, 2, 2677);
			attr_dev(h20, "class", "game-mode-title svelte-oe7jt1");
			add_location(h20, file$2, 107, 6, 2899);
			attr_dev(img0, "class", "game-mode-image svelte-oe7jt1");
			if (img0.src !== (img0_src_value = "https://www.fillmurray.com/300/300")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "alt", "Life Score animation");
			add_location(img0, file$2, 108, 6, 2949);
			attr_dev(div10, "class", "game-mode-header svelte-oe7jt1");
			add_location(div10, file$2, 106, 4, 2862);
			add_location(p1, file$2, 111, 4, 3068);
			attr_dev(div11, "class", "game-mode-description svelte-oe7jt1");
			add_location(div11, file$2, 105, 2, 2822);
			attr_dev(h21, "class", "game-mode-title svelte-oe7jt1");
			add_location(h21, file$2, 115, 6, 3457);
			attr_dev(img1, "class", "game-mode-image svelte-oe7jt1");
			if (img1.src !== (img1_src_value = "https://www.placecage.com/c/300/300")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "Death Score animation");
			add_location(img1, file$2, 116, 6, 3508);
			attr_dev(div12, "class", "game-mode-header svelte-oe7jt1");
			add_location(div12, file$2, 114, 4, 3420);
			add_location(p2, file$2, 118, 4, 3625);
			attr_dev(div13, "class", "game-mode-description svelte-oe7jt1");
			add_location(div13, file$2, 113, 2, 3380);
			attr_dev(div14, "class", "descriptions svelte-oe7jt1");
			add_location(div14, file$2, 104, 0, 2793);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, h1, anchor);
			append_dev(h1, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, p0, anchor);
			append_dev(p0, t3);
			insert_dev(target, t4, anchor);
			insert_dev(target, ul, anchor);
			append_dev(ul, li0);
			append_dev(li0, div2);
			append_dev(div2, div0);
			mount_component(splitsvg, div0, null);
			append_dev(div2, t5);
			append_dev(div2, div1);
			append_dev(div1, t6);
			append_dev(ul, t7);
			append_dev(ul, li1);
			append_dev(li1, div5);
			append_dev(div5, div3);
			mount_component(weightsvg, div3, null);
			append_dev(div5, t8);
			append_dev(div5, div4);
			append_dev(div4, t9);
			append_dev(ul, t10);
			append_dev(ul, li2);
			append_dev(li2, div8);
			append_dev(div8, div6);
			mount_component(scoresvg, div6, null);
			append_dev(div8, t11);
			append_dev(div8, div7);
			append_dev(div7, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, div9, anchor);
			append_dev(div9, t14);
			insert_dev(target, t15, anchor);
			insert_dev(target, div14, anchor);
			append_dev(div14, div11);
			append_dev(div11, div10);
			append_dev(div10, h20);
			append_dev(h20, t16);
			append_dev(div10, t17);
			append_dev(div10, img0);
			append_dev(div11, t18);
			append_dev(div11, p1);
			append_dev(p1, t19);
			append_dev(div14, t20);
			append_dev(div14, div13);
			append_dev(div13, div12);
			append_dev(div12, h21);
			append_dev(h21, t21);
			append_dev(div12, t22);
			append_dev(div12, img1);
			append_dev(div13, t23);
			append_dev(div13, p2);
			append_dev(p2, t24);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const splitsvg_changes = (dirty & /*svgProps*/ 2)
			? get_spread_update(splitsvg_spread_levels, [get_spread_object(/*svgProps*/ ctx[1])])
			: {};

			splitsvg.$set(splitsvg_changes);

			if (!current || dirty & /*shouldAnimate*/ 1 && div2_class_value !== (div2_class_value = "slide-animation-wrapper first " + (/*shouldAnimate*/ ctx[0] && "done") + " svelte-oe7jt1")) {
				attr_dev(div2, "class", div2_class_value);
			}

			const weightsvg_changes = (dirty & /*svgProps*/ 2)
			? get_spread_update(weightsvg_spread_levels, [get_spread_object(/*svgProps*/ ctx[1])])
			: {};

			weightsvg.$set(weightsvg_changes);

			if (!current || dirty & /*shouldAnimate*/ 1 && div5_class_value !== (div5_class_value = "slide-animation-wrapper second " + (/*shouldAnimate*/ ctx[0] && "done") + " svelte-oe7jt1")) {
				attr_dev(div5, "class", div5_class_value);
			}

			const scoresvg_changes = (dirty & /*svgProps*/ 2)
			? get_spread_update(scoresvg_spread_levels, [get_spread_object(/*svgProps*/ ctx[1])])
			: {};

			scoresvg.$set(scoresvg_changes);

			if (!current || dirty & /*shouldAnimate*/ 1 && div8_class_value !== (div8_class_value = "slide-animation-wrapper third " + (/*shouldAnimate*/ ctx[0] && "done") + " svelte-oe7jt1")) {
				attr_dev(div8, "class", div8_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(splitsvg.$$.fragment, local);
			transition_in(weightsvg.$$.fragment, local);
			transition_in(scoresvg.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(splitsvg.$$.fragment, local);
			transition_out(weightsvg.$$.fragment, local);
			transition_out(scoresvg.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(p0);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(ul);
			destroy_component(splitsvg);
			destroy_component(weightsvg);
			destroy_component(scoresvg);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(div9);
			if (detaching) detach_dev(t15);
			if (detaching) detach_dev(div14);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const svgProps = {
		width: "80%",
		height: "auto",
		fill: "#f69d3c"
	}; // stroke: 'rgba(0,0,0,0.2)',

	let shouldAnimate = false;

	setTimeout(
		() => {
			$$invalidate(0, shouldAnimate = true);
		},
		1000
	);

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<How_it_works> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("How_it_works", $$slots, []);

	$$self.$capture_state = () => ({
		SplitSvg: Score,
		WeightSvg: Weight,
		ScoreSvg: Score,
		svgProps,
		shouldAnimate
	});

	$$self.$inject_state = $$props => {
		if ("shouldAnimate" in $$props) $$invalidate(0, shouldAnimate = $$props.shouldAnimate);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [shouldAnimate, svgProps];
}

class How_it_works extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "How_it_works",
			options,
			id: create_fragment$2.name
		});
	}
}

export default How_it_works;
